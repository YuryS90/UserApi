    /**
     * Получаем и обрабатываем данные пришедшие в формате json
     * @return array|mixed
     */
    public function getJsonParams()
    {
        if (!$this->jsonParams) {
            $getContents = $this->request->getBody()->getContents();
            $this->jsonParams = json_decode($getContents, true) ?? [];
        }

        return $this->jsonParams;
    }

    /**
     * Получаем и обрабатываем данные пришедшие из POST
     * @return array|mixed
     */
    public function getPostParams()
    {
        if (!$this->postParams) {
            $this->postParams = $this->request->getParsedBody() ?? [];
        }

        return $this->postParams;
    }

    /**
     * Получаем и обрабатываем данные пришедшие из GET
     * @return mixed
     */
    public function getQueryParams()
    {
        if (!$this->queryParams) {
            $this->queryParams = $this->request->getQueryParams() ?? [];
        }

        return $this->queryParams;
    }

    // ПОлучние имени маршрута
    $this->dd((RouteContext::fromRequest($this->request))->getRoute()->getName());


        // В Laravel есть метод old, которе испл в инпуте атрибута value
        // value="{{old('age')}}" name="age" - если какое из полей прошло валидацию
        // то делаем чтобы пользователь не вводил дважды допущенную инфу


$app = $GLOBALS['app'];
$routes = $app->getRouteCollector()->getRoutes();
$patterns = [];
foreach ($routes as $k => $route) {
$patterns[$k] = $route->getPattern();
}



<?php

namespace App\Middleware;

use Psr\Http\Message\ResponseInterface;
use Slim\Exception\HttpBadRequestException;
use Slim\Exception\HttpForbiddenException;

class ExceptionMiddleware extends AbstractMiddleware
{
    public function run(): ResponseInterface
    {
        try {
            return $this->handle();

        } catch (HttpBadRequestException $exception) {
            return $this->respondException(400, $exception);

        } catch (HttpForbiddenException $exception) {
            return $this->respondException(403, $exception);

        } catch (\Error $exception) {
            return $this->respondException(520, $exception);

        } catch (\ErrorException $exception) {
            $this->dd('проверка 1', $exception);
            return $this->respondException(502, $exception);

        } catch (\Slim\Exception\HttpNotFoundException $exception) {
            $this->dd('проверка 2', $exception);
        }

         catch (\Exception $exception) {
            return $this->respondException(500, $exception);

        } catch (\Throwable $exception) {
            $this->dd('проверка 3', $exception);
            return $this->respondException(401, $exception);
        }
    }
}


Нужно чтобы зарегалось 2 пользователя с ошибками логина и почты (по 2 сообщения).
Чтобы убедиться после регистрации второго, что в $errors при валидации не было сообщений сразу для двух


feat: Используется для указания новой функциональности или добавления нового компонента.
fix: Используется для исправления ошибок или дефектов в коде.
docs: Используется для обновления документации или комментариев в коде.
style: Используется для изменений форматирования кода, таких как исправление отступов, пробелов и т.д., без изменения его функциональности.
refactor: Используется для переработки кода без добавления новой функциональности или исправления ошибок.
test: Используется для добавления, изменения или исправления тестового кода.
chore: Используется для обновления задач по автоматизации сборки, настройке среды разработки и другими подобными задачами.
