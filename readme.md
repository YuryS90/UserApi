##Общая информация

**Аутентификация** — процедура проверки подлинности, например проверка подлинности пользователя путем сравнения 
введенного им пароля с паролем, сохраненным в базе данных.

**Способы аутентификации:**

- Аутентификация при помощи электронной подписи

- Аутентификация по паролям

- Аутентификация с помощью SMS

- Биометрическая аутентификация

- Аутентификация через географическое местоположение

- Многофакторная аутентификация
  
- Двухфакторная аутентификация


Двухфакторная аутентификация – это система идентификации пользователя 
с использованием двух разных способов. Цель такого метода аутентификации – сделать защиту 
аккаунта пользователя более эффективной и надежной.


Как работает двухфакторная аутентификация?

Самый простой и распространенный вариант – это использование 
для авторизации логина и пароля (на первом шаге) и одноразового 
пароля из СМС (на втором шаге). Помимо СМС возможны такие варианты:

- Email

- Звонок

- Push-уведомление

- Биометрические данные пользователя (отпечаток пальца, фото роговицы глаза)

- Электронная подпись (на USB, на сервере)

- Токен

- Смарт карта

- Лист с одноразовыми паролями


_________________

**Авторизация** — предоставление определенному лицу или группе 
лиц прав на выполнение определенных действий.

Виды авторизации:

- методом разграничения прав (на основе ролей, мандатное, избирательное);

- способом доступа (онлайн/офлайн);

- количеством проверок (одно- или многоступенчатые).

_________________

**Верификация** — простыми словами, это технология проверки информации
на достоверность, правильность, точность.
Процедура проверки на подлинность вашего профиля, документа или действия

_________________

Процесс проверки корректности данных называется **валидацией**

Правила валидации данных:

- Обязательные поля: 
Проверьте, что все поля, которые должны быть заполнены обязательны, были заполнены. 
Если какое-то из обязательных полей не заполнено, то 
выдайте сообщение об ошибке, и не допускайте отправки формы.

- Корректный формат данных:
Проверьте, что данные соответствуют правильному формату, 
например, email должен быть корректным, номер телефона должен быть в правильном формате, 
и т.д.

- Длина данных: 
Проверьте, что данные соответствуют определенной длине, 
например, пароль должен быть не менее 6 символов.

- Уникальность: 
Если данные должны быть уникальными, проверьте, что введенные данные 
действительно уникальны, например, email не должен совпадать с уже существующим в БД.

- Безопасность: 
Проверьте, что данные не содержат вредоносный код, например, скрипты, SQL-инъекции и т.д.

- Приведение типов: 
Приведите данные к нужному типу, например, число к целочисленному типу.

> Важно проверять данные как на стороне клиента, 
> так и на стороне сервера, чтобы обеспечить максимальную защиту 
> от ошибок и злоумышленных действий.
> 
> Можно использовать разделение правил валидации на разные классы. 
> Это позволяет более гибко настраивать валидацию, а также обеспечивает легкую 
> поддержку и расширение кода.
_________________

## Реализация класса регистрации

        // План предварительной регистрации (CreateController)
        // 1 Поймал данные json
        // 2 Обработал их, если ошибка, вернул её (статус 400)
        // 3 Сгенерироривал пароль
        // 4 1-й этап добавления со сгенерированным паролем
        // 5 Отправка на почту пароля
        // 6 Вернул статус 201

При регистрации пользователя форма должна иметь поля (name=):

- login

- email

- pwd

- confirm_pwd

Валидация данных

Метод validated

Для каждого правила валидации определен отдельный метод валидации,
который вызывается из метода validate в соответствии с правилом и данными


        //if ($pdo->insert('users', $data)->statement->errorInfo()) {
        //    $this->response->getBody()
        //        ->write(json_encode(([
        //            'error' => $pdo->insert('users', $data)->statement->errorInfo()[2]
        //        ]), JSON_UNESCAPED_UNICODE));
        //'login' => "' or 1=1 #",

### Требования к логину, почте и паролю при валидации.

- Пароль:
Может содержать как латинские, так и кириллические буквы, цифры и специальные символы;
должен содержать не менее 8 символов;

- Должен содержать хотя бы одну заглавную букву, одну строчную букву, одну цифру и 
один специальный символ;

- Не должен быть слишком простым, например, не должен содержать только последовательность 
цифр или букв.


Для защиты приложения от инъекций и атак, а также 
для обеспечения безопасности пользователей при создании паролей, 
следует применять следующие подходы:

Подключение к базе данных через подготовленные запросы или ORM: 
Используйте подготовленные запросы или объектно-реляционные отображения (ORM) 
для выполнения запросов к базе данных. Это поможет предотвратить SQL-инъекции.

Валидация и санитизация входных данных: 
Всегда проверяйте и фильтруйте входные данные, получаемые от пользователей, 
прежде чем использовать их в приложении. Используйте функции валидации, фильтрации и 
санитизации данных, предоставляемые фреймворком или библиотекой.

Хэширование и соление паролей: Храните пароли пользователей в захэшированном виде 
с использованием соли. Хэширование паролей делает их непонятными 
даже в случае компрометации базы данных.

Использование параметризованных запросов при работе с базой данных: 
При выполнении запросов к базе данных используйте параметризованные запросы, 
чтобы предотвратить возможность инъекций данных.

Ограничение прав доступа: Установите строгие права доступа к файлам и папкам 
внутри приложения, чтобы предотвратить нежелательный доступ к конфиденциальным данным 
или исполняемым файлам.

Отключение вывода ошибок: Включите режим отображения ошибок только для разработки 
и отключите его в продакшене. Это поможет предотвратить возможность получения 
злоумышленником конфиденциальной информации об ошибке.

Защита от CSRF-атак: Используйте механизмы защиты от межсайтовой подделки запроса (CSRF), 
чтобы предотвратить злоумышленникам выполнение нежелательных действий от имени 
авторизованных пользователей.

Обновление и обеспечение безопасности зависимостей: Регулярно обновляйте все зависимости 
и библиотеки, используемые в приложении, чтобы устранить известные уязвимости и обеспечить 
безопасность.

Обучение пользователей: Обучайте пользователей создавать надежные пароли, 
избегать общих паролей и использовать функции двухфакторной аутентификации для 
дополнительной защиты.


Оба регулярных выражения /^[\p{L}\p{N}_]+$/u и /^[A-Za-zА-Яа-я0-9_]$/ предназначены для проверки, что строка состоит только из определенных символов (латинских и кириллических букв, цифр и знака подчеркивания).

Однако, есть несколько отличий:

Юникод: /^[\p{L}\p{N}_]+$/u поддерживает юникодные символы, что означает, что он сможет обрабатывать кириллические символы и другие символы из различных языков. /^[A-Za-zА-Яа-я0-9_]$/ не является юникодным выражением, и оно будет считывать только ASCII символы и кириллические символы.

Количественное совпадение: /^[\p{L}\p{N}_]+$/u проверяет, что строка содержит один или более символов из указанных классов. То есть, это выражение проверяет, что вся строка состоит только из символов, перечисленных в классе. /^[A-Za-zА-Яа-я0-9_]$/ проверяет только один символ в строке, поэтому оно не сможет обработать строки длиннее одного символа.

Выбор между этими регулярными выражениями зависит от ваших конкретных требований и 
ожидаемых данных. Если вам нужна поддержка юникодных символов и 
возможность проверки строк длиннее одного символа, то /^[\p{L}\p{N}_]+$/u будет более 
подходящим. Если ваши данные ограничены ASCII символами и вам не требуется поддержка 
юникода, то /^[A-Za-zА-Яа-я0-9_]$/ может быть достаточным.

Регулярное выражение для проверки формата email адреса '/^[^\s@]+@[^\s@]+\.[^\s@]+$/ui' соответствует стандартному формату адреса, где:

^[^\s@]+ соответствует одному или более символам, не являющимся пробелом или символом "@" в начале адреса.
@[^\s@]+ соответствует символу "@" и одному или более символам, не являющимся пробелом или символом "@" в доменном имени.
\.[^\s@]+$ соответствует символу "." и одному или более символам, не являющимся пробелом или символом "@" в доменной зоне.


_________________


> Подсказки
> 
> Строка от браузера может приходить к примеру в cp1251, а на сервере скрипты в utf-8 или кои.
> И регулярки с кириллицей работать не будут
> (или будут, но "неожиданно" и неправильно).
> Рекомендация - переводите все в одну кодировку.
> 
> 
>
    // Маршруты админа
    //$app->group('/admin', include 'app/routes/admin/admin.php');

    // Маршруты SMM
    //$app->group('/user', include 'app/routes/user/user.php');

    // Маршруты гостей
    //$app->group('/user', include 'app/routes/user/user.php');



Версии  проекта
v0.3.* - Работа над созданием добавления пользователя